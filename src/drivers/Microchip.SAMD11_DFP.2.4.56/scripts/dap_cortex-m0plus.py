# This file is autogenerated
comm_speed=2000000
erase_as_needed = True  # used in prog_write
comm_iface = True
reset_delay = 0
has_reset = True
show_output = False
log_level = 0

def _begin_debug_session():
    dev.Connect(comm_iface, comm_speed)
    reset_and_halt()
    cache_onDebugStart()

def _begin_communication_session(): 
    global log_level,show_output,reset_delay, target_was_reset, has_reset, _stealth_runstate    
    log_level    = settings.getNumeric("script.log_level",log_level)
    show_output  = settings.getBool("script.show_output",show_output)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)

    target_was_reset = False
    _stealth_runstate = 2
    dev.SetApiLogging(log_level)
    log.setShowOutput(show_output)

    global comm_iface, comm_speed, erase_as_needed
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    erase_as_needed = True  # used in prog_write

def _end_communication_session(): 
    _end_of_operations()

def onShowPropsDFP2(t):
    ide.addBooleanProperty(t,"arm.use_vtor" , "*|programoptions|programoptions.eraseb4program","Set PC and SP to VTOR","After reset, force PC and SP to the entries defined by the VTOR", False)
    ide.addTextProperty(t,"arm.vtor_adr" , "*|programoptions|programoptions.eraseb4program","VTOR table or numerical address", "Enter address of vector table", "exception_table")
    ide.addPropCategory(t,"diagnostics" , "*|toolpack", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)

def print_dhcsr_v(t, d):
    log.info(t + arm.getDHCSRString(d))

def print_dhcsr(text):
    try:
        d = dev.Read32(arm.DHCSR)
        print_dhcsr_v(text, d)
        return d
    except:
        log.log("DHCSR is unreadable")
        return 0

def _debug_read(mt, start, length, data):
    cache_onDataRead(start,length)
    _prog_read(mt, start, length, data)

def _debug_write(mt, start, length, data):
    if str(mt) == "Pgm":
        cache_invalidateInstrCache()
        _flash_write(start, length, data, True)
        return

    cache_onDataWrite(start,length)
    dev.Write(start, data, 0, length)

def _get_pc():
    try:
        pc = dev.ReadReg64(15)
    except:
        log.error("get_pc returned error")
        return 0
    return pc

def _get_reg(idx):
    return dev.ReadReg64(idx)

def _set_reg(idx,val):
    return dev.WriteReg64(idx,val)

def _mem_read(start, length, data):
    dev.Read(start, data, 0, length)

def _mem_write(start, length, data):
    dev.Write(start, data, 0, length)

def _run_target():
    cache_onRun()
    dev.Write32(arm.DHCSR, 0xa05f0001)  # DBGKEY | C_DEBUGEN | C_HALT

def _halt_target():
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT

def _step_target():
    cache_onRun()
    dev.Write32(arm.DHCSR, 0xa05f000b)  # DBGKEY | C_DEBUGEN | C_HALT | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f000d)  # DBGKEY | C_DEBUGEN | C_STEP | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT
    cache_onStop()

def _set_pc(pc):
    dev.WriteReg64(15, pc)

def print_byte_array(text, array, index, size):
    string = text
    for i in range(size):
        string += " %x" % array[i+index]
    log.info(string)

g_is_running = True
def _is_target_running():
    global g_is_running
    dhcsr = dev.Read32(arm.DHCSR)
    state = 0 == (dhcsr & 0x20000)
    if state != g_is_running:
        log.info("Debug: target is now running" if state else "Debug: target has halted")
        g_is_running = state 
    if not g_is_running:
        cache_onStop()
    return g_is_running

def on_after_reset(): 
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        dev.WriteReg64(arm.PC,dev.Read32(adr + 4))
        dev.WriteReg64(arm.SP,dev.Read32(adr))
    except:
        log.error("Debug: failed to set PC and SP to vtor[0] and vtor[4], with vtor=0x%08x" % adr)


def on_program_done():
    on_after_reset()

def _reset_target(): 
    reset_and_halt()

def _end_debug_session(): 
    run_target()
    dev.Disconnect()

def _hold_in_reset(): 
    global target_was_reset
    global has_reset
    if not has_reset:
        alt_hold_in_reset()
        return
    log.info("Prog: Hold in reset")
    try:
        dev.SetInterface(dev.SWD)
    except:
        dev.Connect(True, 100000)
    dev.Pins(0, dev.RESET, 1000)
    target_was_reset = True
    # do not dev.Disconnect() . The debugger needs to stay connected to actively keep the reset line low.

def alt_hold_in_reset(): 
    # Alternative if RESET pin is not connected to debugger
    log.info("Prog: Hold in reset , no reset line")
    dev.Connect(True, 100000)
    reset_and_halt()

def _release_from_reset():
    global target_was_reset,reset_delay
    global has_reset
    if target_was_reset:
        return
    if not has_reset:
        log.info("Prog: Release from reset (soft reset)")
        dev.Connect(True, 100000)
        reset_and_halt()
        run_target()
        return

    log.info("Prog: Release from reset (float reset line)")

    # toggle reset line
    try:
        dev.SetInterface(dev.SWD)
    except:
        dev.Connect(True, 100000)
    dev.Pins(0, dev.RESET, 1000)
    dev.Delay(reset_delay)
    dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
    dev.Delay(reset_delay)
    target_was_reset = True
    dev.Disconnect() #we are done with the part

def alt_release_from_reset():
    log.info("Prog: Release from reset, no reset line")
    dev.Connect(True, 100000)
    dev.Write32(dev.AIRCR, 0x05fa0004)  # VECTKEY | SYSRESETREQ

def set_sw_bp_gen(address, erase_size, instruction, flags):  #mplab
    global erase_as_needed
    log.debug("Debug: set/reset bp at address 0x%0x, store instructions 0x%0x, flags = 0x%0x" % (address, instruction, flags))
    if address >= 0x20000000:
        erase_size = 4 
    else:
        clear_and_report_flash_error()


    erase_page_start = address & ~(erase_size-1)
    address_in_erase_page = address & (erase_size-1)

    data = bytearray(erase_size)
    cache_invalidateInstrCache()
    dev.Read(erase_page_start, data, 0, erase_size)
    return_value = data[address_in_erase_page] | (data[address_in_erase_page+1] << 8)

    # Insert software breakpoint instruction in the data
    data[address_in_erase_page] = instruction & 0xFF
    data[address_in_erase_page+1] = (instruction >> 8) & 0xFF

    if erase_size == 4:
        dev.Write(erase_page_start, data, 0, erase_size)
    else:
        erase_as_needed = True
        prog_write("Pgm", erase_page_start, erase_size, data)
    return return_value


# device specific functions

dsu_statusa = 0x41002101
dsu_ctrl = 0x41002100
    
class nvm:
    page_size = 64
    erase_size = 256
    aux_size = 256
    cmdReg = 0x41004000
    cfgReg  = 0x41004004
    stsReg = 0x41004018
    intReg = 0x41004014
    adrReg = 0x4100401c
    AUX_ERASE = 0xA505
    ROW_ERASE = 0xA502
    RWW_ERASE = 0xA51A
    RWW_WRITE = 0xA51C
    erase_time = 100
    UROW = 0x00804000
    RWW = 0x00400000
    SSB  = 0xA545

def cache_invalidate():
    nvm_cmd(0xA546,20)
def cache_onDebugStart():
    cache_invalidate()
def cache_onStop():
    cache_invalidate()

def cache_onRun():
    pass    
def cache_onDataRead(adr,size):
    pass #done in onStop
def cache_onDataWrite(adr,size):
    pass #done in onStop
def cache_invalidateInstrCache():
    pass #done in onStop


def is_nvm_ready():
    intFlag = dev.Read8(nvm.intReg)
    isReady = 0 != (intFlag & 1)
    isError = 0 != (intFlag & 2)
    if not isError: # if no ERROR bit is set
        return isReady

    status = dev.Read16(nvm.stsReg)
    log.error("NVMCtrl error bits set! (STATUS = 0x%X, INTFLAG = 0x%X)" % (status, intFlag))
    dev.Write16(nvm.stsReg, status | 0x001E) # clear error bits and load bit by setting 1
    dev.Write8(nvm.intReg, intFlag | 2) # clear error bit by setting 1
    raise Exception("NVMctrl reports an error")

def clear_and_report_flash_error():
    try:
        is_nvm_ready()
    except:
        log.error("NVM controller is in an error state while setting a swbp. Clearing the error")

# global variable keeps previous value of flash cfg register while programming
prevCfgReg = 0x0

def cfg_nvmctrl():
    global prevCfgReg
    prevCfgReg = dev.Read32(nvm.cfgReg)
    newCfgReg = (prevCfgReg & 0xFFFFFF61) | 0x1e  # 15 wait states and clear MANW
    if newCfgReg != prevCfgReg:
        dev.Write32(nvm.cfgReg, newCfgReg)

def restore_nvmctrl():
    #log.debug("reset_cfg_word: prevCfgReg = %x" % prevCfgReg)
    dev.Write32(nvm.cfgReg, prevCfgReg)

def erase_row(addr,cmd):
    dev.Write32(nvm.adrReg,addr/2)
    nvm_cmd (cmd, 20)

def _begin_programming_operation():
    global erase_as_needed,has_reset
    erase_as_needed = True
    reset_extension()
    dev.Connect(comm_iface, comm_speed)
    if has_reset:
        statusa = dev.Read8(dsu_statusa) # verify CRSTEXT is set
        if 0 == (statusa & 2): #STATUSA.CRSTEXT
            log.error("Device could not enter reset extension, check cap on RST line")
            raise Exception("Reset error.")
        else:
            log.info("Device entered reset extension")
    try:
        reset_and_halt()  # clear CRSTEXT
    except:
        pass

def reset_extension():
    global reset_delay # additional delay for reset line if needed
    global has_reset
    if not has_reset:
        return

    delay=1000  # time to  wait for analog RESET/SWCLK pins to become digitally high/low
    try:
        dev.SetInterface(dev.SWD)
    except:
        dev.Connect(comm_iface, comm_speed)
    dev.Pins(0,dev.RESET,delay)  # 1 msec with reset high 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(dev.RESET,dev.RESET,delay) # 1 msec with floating reset 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(0,dev.RESET | dev.SWCLK,delay); # 1 msec with reset and clock low 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(dev.RESET,dev.RESET,delay); # now float reset back
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Delay(10000)

def _read_device_id():
    return dev.Read32(0x41002118) # DSU-DID register

set_security_bit  = False 

def _erase():
    global erase_as_needed
    global set_security_bit

    set_security_bit = False

    dsu_ce = 0x10
    dev.Write8(dsu_ctrl, dsu_ce) # 0x41002100,0x10

    n = 0
    while n < nvm.erase_time:
        statusa=dev.Read8(dsu_statusa) # 0x41002101
        if statusa & 1: #statusa_done
            if statusa & 0x1c:
                log.error("DSU.STATUSA indicates an error %x"  % statusa)
                raise Exception("Erase error")
            break
        dev.Delay(100000)
        n=n+1
    erase_as_needed = False # tell prog_write not to erase rows prior to write
    reset_extension() # reset_extension is required after a chip erase when chip(e.g. SAME54) was secured
    dev.Connect(comm_iface, comm_speed)
    reset_and_halt()
    if settings.getBool("x.erase.clearprot", True):
        restoreBOOTPROTandNVMCTRLREGIONLOCKS()

def reset_and_halt():
    halt_target()
    dev.Write32(arm.DEMCR, 0x01000001) # TRCENA  | VC_CORERESET
    dev.Write32(arm.AIRCR, 0x05fa0004) # VECTKEY | SYSRESETREQ
    n = 0
    retries = 10
    seenReset = False
    while n<retries:
        dhcsr = dev.Read32(arm.DHCSR)
        #print_dhcsr_v("arm.DHCSR",dhcsr)
        if (dhcsr & 0x02000000): # wait for S_RESET_ST
            seenReset=True
            dev.Write32(arm.DHCSR, 0xa05f0003) # DBGKEY|C_HALT|C_DEBUGEN
            dev.Write8(dsu_statusa, 2) # release the cpu 0x41002101,0x2  STATUSA.CRSTEXT
            dhcsr = print_dhcsr("Cleared CRSTEXT")
        hasHalted = 0 != (dhcsr & 0x20000) # S_HALT
        if seenReset:
            if hasHalted: # wait for S_HALT
                break
        dev.Delay(100000)
        n=n+1
    dev.Write32(arm.DEMCR, 0x01000000) # TRCENA
    if n==retries:
        raise Exception("The device did not come out of reset")

def nvm_cmd(command, t):
    dev.Write16(nvm.cmdReg, command)
    wait_nvm_ready(t)

def wait_nvm_ready(t):
    while t > 0 :
        if is_nvm_ready():
            return
        dev.Delay(1000)
        t  = t - 1
    if t == 0:
        raise Exception("The NVM controller operation did not finish")

def write_row(adr, ofs, data,len):
    dev.Write(adr, data, ofs , len)
    wait_nvm_ready(10)

def _prog_write(type_of_mem, address, length, data): 
    global erase_as_needed
    if address == 0x41004000:
        if length < 1:
            log.error("Empty security bit payload")
            return
        global set_security_bit
        set_security_bit = data[0] != 0
        if set_security_bit:
            log.info("Will set the security bit")
        return

    if str(type_of_mem) != "Pgm" and  str(type_of_mem) != "Cfg" and str(type_of_mem) != "RWW":
        dev.Write(address, data, 0, length)
        return
    if address == nvm.UROW: # user page / fuses / configuration bits
        _flash_write_rng(address,length,data,nvm.AUX_ERASE)
        reset_and_halt()
    else:
        erase_cmd = nvm.RWW_ERASE if str(type_of_mem) == "RWW" else nvm.ROW_ERASE
        _flash_write_rng(address,length,data,erase_cmd if erase_as_needed else 0)

    erase_as_needed = True

def _flash_write_rng(address, length, data, erase_cmd):
    cfg_nvmctrl()
    written = 0
    # a flash row has 'erase_size' bytes
    while written < length:
        if erase_cmd != 0:
            erase_row(address, erase_cmd)
        if erase_cmd == nvm.AUX_ERASE:
            dev.Read32(address) # fix for MPLABX-4768. For the particular project provided in the Jira ticket, MPLAB need to to a read before write, otherwise the PC will be 0
        write_row(address,written,data, min(length - written, nvm.erase_size))
        #dev.Read(address,data1,0,nvm.erase_size)
        written += nvm.erase_size
        address += nvm.erase_size
    restore_nvmctrl()

def _flash_write(address, length, data, doerase): # for swbps
    _flash_write_rng(address, length, data, nvm.ROW_ERASE)

def _prog_read(type_of_mem, address, length, data):    
    dev.Read(address,data,0,length)

def _end_of_operations():
    global erase_as_needed,set_security_bit
    erase_as_needed = True

    if set_security_bit:
        log.info("Setting security bit")
        try:
            nvm_cmd(nvm.SSB,20)
        except:
            pass

        set_security_bit = False
    #reset_and_halt()
    dev.Disconnect()

def set_sw_bp(address, instruction, flags):#mplab
    return set_sw_bp_gen(address,nvm.erase_size,instruction,flags)

def restoreBOOTPROTandNVMCTRLREGIONLOCKS():
    b=bytearray(nvm.page_size)
    dev.Read(nvm.UROW, b, 0, nvm.page_size)
    if "M0" in architecture:
        if "JH" in device and "PIC32CM" in device:
            b[0] = b[0] | 0x0F # clear BOOTPROT
        else:
            b[0] = b[0] | 0x07 # clear BOOTPROT
        b[6] = 0xFF # clear NVMCTRL_REGION_LOCKS
        b[7] = 0xFF # clear NVMCTRL_REGION_LOCKS
    elif "M4" in architecture:
        b[3] = b[3] | 0x3C # clear BOOTPROT
        b[8] = 0xFF # clear NVMCTRL_REGION_LOCKS
        b[9] = 0xFF # clear NVMCTRL_REGION_LOCKS
        b[10] = 0xFF # clear NVMCTRL_REGION_LOCKS
        b[11] = 0xFF # clear NVMCTRL_REGION_LOCKS
    prog_write("Cfg", nvm.UROW, nvm.page_size, b)
def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    log.info("Begin operations")
    _begin_programming_operation()

def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(arm.PC,pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.error("Not-implemented Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    return True

def blank_check():  #mplab
    log.info("Blank check")

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
